<!doctype html>
<html>
	<head>
		<meta charset="UTF-8">
		<link rel="stylesheet" href="../assets/coding.css">
		<title>Tutorial 5</title>
	</head>

	<body>
    	<div id="main-content">
		<h1> GTCS Game Engine: <br>
		Tutorial 5: Illumination</h1>
		<p align="center"><a href="../tutorial4/tutorial4.html">Tutorial 4</a> &lt;-- Tutorial 5 --&gt; <a href="../tutorial6/tutorial6.html">Tutorial 6</a><br>
		  <a href="../index.html">Main tutorial guide page</a><br></p>
		
		
		<hr>
		<h2>Introduction</h2>
		<p>In this tutorial, we are going to look at how to enhance the look of our game scene using lighting effects.</p>
		<p>
		  </p>



	<hr>
		<h2>Illumination</h2>
		<p>In tutorial 2, we have seen the use of ambient lighting to illuminate our renderables. The ambient lighting sources is controlled with the <b>setGlobalAmbientIntensity()</b> function. This source is always active and it adjusts the lighting on all renderables in our scene. If we want to disable the light, we set the intensity to 0. The lighting affect is analagous to increasing the backlight intensity on your cell phone or laptop. Everything gets &quot;brightened&quot; by the same amount.</p>
		<p>The game engine supports 3 other types of light sources.</p>
		<ul>
		  <li>Point - An omnidirectional light source in space. Similar to a hovering firefly with a &quot;sphere of illumination&quot; wherever it goes.</li>
		  <li>Spot - A cone-shaped light source directed at a location. Similar to a flashlight pointing at a wall.</li>
		  <li>Directional - A planar light source where light is equally intense at all incident points. Similar to the screen backlight of electronics devices.</li>
		  </ul>
        <p>These different lighting types have are declared using a number of parameters sent into the Proper use of lighting requires...</p>
        <ol>
        	<li>Declare a light source with the type and parameters defining it's characteristics.</li>
            <li>Idenfity to each applicable renderable that it should account for the light source when drawing itself.</li>
          </ol>
		<p class="note">[Note: This second requirement may seem odd but lighting calculations are essentially a manipulation of how pixels are drawn to the screen (how the object looks). Since we are familiar with the fact that the &quot;look&quot; of game elements is under the purview of the renderable, we treat lighting as a parameter we add to the renderable object.]</p>
        <p>To create a light, we allocate a new Light object and set parameters using accessor methods. There are many settings and certain settings will be used or ignored based on the type of light. An overview of the functions is given below...</p>
        <ul>
          <li><code>setLightType()</code> - Identifies what type of light to render as. Valid choices are <strong>Light.eLightType.ePointLight</strong>, <strong>Light.eLightType.eSpotLight</strong> and<strong> Light.eLightType.eDirectionalLight</strong>.</li>
          <li><code>setColor()</code> - Color of the light using a 4-value vector identifying red, green, blue and alpha values from 0.0 to 1.0</li>
          <li><code>setIntensity()</code> - A value from 0.0 to 1.0 given the strength of the light.</li>
        </ul>
    <figure>
	  	<pre>	// create the light and setup the parameters we need
	var aNewLight = new Light();
	aNewLight.setLightType(Light.eLightType.eDirectionalLight);
	aNewLight.setColor([1.0, 1.0, 1.0, 1]);
	aNewLight.setIntensity(1);
    	</pre>
    	<figcaption>Code snippet 5-1: Defining a Light Object</figcaption>
    </figure>
    <h3>Point Lights</h3>
    <p>A point light can be compared to a lightbulb hovering in mid-air illuminating a spherical volume around it. It has intensity, color, size and position. The amount of the game scene that will be illuminated with be determined by the size of the illumination volume (determined by the radius of affect from the center point) and the location of the point. Figure 5-1 provides a visual representation of the affect. To create a point light, we allocate a new Light object and set parameters using accessor methods.</p>
    <figure>
    		<img src="assets/tutorial5-img1.png" width="466" height="211">
        	<figcaption>figure 5-1: Point Light</figcaption>
        </figure></p>
    <p>To create a point light, we allocate a new Light object and set parameters using accessor methods.</p>
    <h3>Spot Lights</h3>
    <p>Spot lights are more complex than point lights. There have many more parameters that needs to be provided. Figure 5-2 illustrates how a spot light illuminates a surface.</p>
    <p><figure>
    		<img src="assets/tutorial5-img2.png" width="370" height="211">
        	<figcaption>figure 5-2: Spot Light</figcaption>
        </figure></p>
    <h3>Directional Lights</h3>
		<p>A directional light is similar to ambient light in that every pixel illunated by it receives the light with equal intensity. However, while the ambient light source allows us to set just the intensity, we can also define direction and color for directional light sources. Since we are dealing with two dimensional renderables, the direction of the light is not going to provide a sense of depth like it would in three dimensional space. We ignore the directional component for now and set the intensity and color using <code>setLightColor()</code> and <code>setLightIntensity()</code>.</p>
        
	<figure>
	  <pre>function MyGameScene() {
	this.mCamera = null;
	this.mRenderable = null;
	this.mGameObject = null;
	<b>this.mDirLight = null;</b>
    
	this.kTexture = "assets/minion_sprite.png"
};
gEngine.Core.inheritPrototype(MyGameScene, Scene);

function loadScene() {
	gEngine.Textures.loadTexture(this.kTexture);
    
function unloadScene() {
	gEngine.Textures.unloadTexture(this.kTexture);
};

MyGameScene.prototype.initialize = function () {
	this.mCamera = new Camera(
		vec2.fromValues(50, 40),    // position of the camera
		100,                        // width of camera
		[0, 0, 500, 400]            // viewport (orgX, orgY, width, height)
	);
	// set the background color of our view to medium grey
	this.mCamera.setBackgroundColor([0.8, 0.8, 0.8, 1]);
    
	<b>// we use a new object type that knows how to render with lights
	this.mRenderable = new LightRenderable(this.kTexture);
	this.mRenderable.setElementPixelPositions(130, 310, 0, 180);
	
	// create the light and setup the parameters we need
	this.mDirLight = new Light();
	this.mDirLight.setLightType(Light.eLightType.eDirectionalLight);
	this.mDirLight.setColor([1.0, 1.0, 1.0, 1]);
	this.mDirLight.setIntensity(1);

	// associate the light with the renderable
	this.mRenderable.addLight(this.mDirLight);</b>
    
	// create a new game object with the new renderable
	this.mGameObject = new GameObject(this.mRenderable);
	this.mGameObject.getXform().setSize(16, 16);
	this.mGameObject.getXform().setPosition(30, 50);
    
	<b>// we turn off the ambient light to see our light affect
	gEngine.DefaultResources.setGlobalAmbientIntensity(0);</b>
};
</pre>
		<figcaption class="codecaption">Code snippet 5-2: Using a LightRenderable with Directional Lighting</figcaption>
        </figure>

    <h3>&nbsp;</h3>
    <p>&nbsp;</p>
    <hr>
    <h2>Conclusion</h2>
        <p>In <a href="../tutorial6/tutorial6.html">tutorial 6</a>, we will took a look at implementing shadow affects on our renderables.</p>
        
        
        <hr>
        <p align="center"><a href="../tutorial4/tutorial4.html">Tutorial 4</a> &lt;-- Tutorial 5 --&gt; <a href="../tutorial6/tutorial6.html">Tutorial 6</a><br>
		  <a href="../index.html">Main tutorial guide page</a><br></p>
	</div>
    <h4><i>2/3/2016</i></h4>
    </body>
</html>
