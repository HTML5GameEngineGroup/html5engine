<!doctype html>
<html>
	<head>
		<meta charset="UTF-8">
		<link rel="stylesheet" href="../assets/coding.css">
		<title>Tutorial 3</title>
	</head>

	<body>
    	<div id="main-content">
		<h1> GTCS Game Engine: <br>
		Tutorial 3: Sprites, Animation, Collision&nbsp;Detection & Parallax</h1>
		<p align="center"><a href="../tutorial2/tutorial2.html">Tutorial 2</a> &lt;-- Tutorial 3 --&gt; <a href="../tutorial4/tutorial4.html">Tutorial 4</a><br>
		  <a href="../index.html">Main tutorial guide page</a><br></p>
		
		
		<hr>
		<h2>Introduction</h2>
		<p>In this tutorial, we are going to look at more renderables and expand our understanding of game object behavior by using collision detection.</p>
		
        
        <hr>
		<h2>Files Used</h2>
        <p>Source Code can be downloaded here.</p>
        <p>Image Files</p>
		<p><figure>
        	<img src="assets/minion_sprite.png" width="512" height="256" alt=""/>
            	<figcaption>figure 3-1: Sprite sheet</figcaption>
            </figure>
        </p>


	<hr>
		<h2>Sprites</h2>
		<p>TextureRenderables have a big advantage over Renderables in being able to render a bitmap. They do have a few significant limitations. Our texture must have dimensions that are powers of 2 and they are static. While this may work fine for backgrounds or or static visual elements, we typically want something more dynamic for the &quot;action&quot; graphics in our game. SpriteRenderables allow us to use a sprite sheet and define the portion of the sheet we want to display for the renderable.</p>
		<p>In figure 3-1, we see a sample sprite sheet. You will notice that in the bottom row (second from the left), we have the same image we used in tutorial 2. With coordinate location (0,0) being the bottom left of the entire sprite page, the bottom left coordinate for this sub-image is at (130,0). The size of this sub-image is 180 pixels wide by 180 pixels tall. Using the call <code>setElementPixelPositions(<em>left-x, right-x, lower-y, upper-y</em>);</code> will allow us to define the portion of the sheet we want to render.</p>
	<figure><pre>function MyGameScene() {
	this.mCamera = null;
	this.mRenderable = null;
	this.mGameObject = null;
    
	<b>this.kTexture = "assets/minion_sprite.png"</b>
};
gEngine.Core.inheritPrototype(MyGameScene, Scene);

function loadScene() {
	gEngine.Textures.loadTexture(this.kTexture);
    
function unloadScene() {
	gEngine.Textures.unloadTexture(this.kTexture);
};

MyGameScene.prototype.initialize = function () {
	this.mCamera = new Camera(
		vec2.fromValues(50, 40),    // position of the camera
		100,                        // width of camera
		[0, 0, 500, 400]            // viewport (orgX, orgY, width, height)
	);
	// set the background color of our view to medium grey
	this.mCamera.setBackgroundColor([0.8, 0.8, 0.8, 1]);
    
	<b>// we now use a sprite renderable object
	this.mRenderable = new SpriteRenderable(this.kTexture);
	this.mRenderable.setElementPixelPositions(130, 310, 0, 180);</b>
    
	// create a new game object with the new renderable
	this.mGameObject = new GameObject(this.mRenderable);
	this.mGameObject.getXform().setSize(16, 16);
	this.mGameObject.getXform().setPosition(30, 50);
    
	gEngine.DefaultResources.setGlobalAmbientIntensity(3);
};
</pre>
		<figcaption class="codecaption">Code snippet 3-1: Adding a SpriteRenderable</figcaption>
        </figure>
        <p>If you make the above changes to your code, you will notice that the scene looks exactly the same. So far, this doesn't seem very useful until we consider that we can consolidate all of our textures onto a single sprite sheet and that our renderable textures can be of arbitrary dimensions.</p>
        <p>Unlike a TextureRenderable, SpriteRenderable allows us to change the renderable being shown by changing the element pixel position of the sprite sheet. There is an identical minion facing the opposite direction at (720,0). The size is still 180x180 so calling <code>this.mRenderable.setElementPixelPositions(720, 900, 0, 180);</code> will allow our sprite to appear to change direction.</p>
        <p>Below, we modify our <strong>update()</strong> function to make the sprite change directions based on the keyboard controls.</p>
        
        <figure><pre>MyGameScene.prototype.update = function () {
	// Check for user keyboard input to control GameObject
	if (gEngine.Input.isKeyPressed(gEngine.Input.keys.A)) {
		<b>this.mRenderable.setElementPixelPositions(130, 310, 0, 180);</b>
		this.mGameObject.getXform().incXPosBy(-0.5);
	}
        
	if (gEngine.Input.isKeyPressed(gEngine.Input.keys.D)) {
		<b>this.mRenderable.setElementPixelPositions(720, 900, 0, 180);</b>
		this.mGameObject.getXform().incXPosBy(0.5);
	}
     
	if (gEngine.Input.isKeyClicked(gEngine.Input.keys.Q)) {
		gEngine.GameLoop.stop();
	}</b>
};</pre>
		<figcaption class="codecaption">Code snippet 3-2: Update</figcaption>
        </figure>


	<hr>
		<h2>Sprite Animation</h2>
		<p>We can take our SpriteRenderable concept another step forward by defining and automatic animation for it.</p>
        
        <figure>
          <pre>function MyGameScene() {
	this.mCamera = null;
	this.mRenderable = null;
	this.mGameObject = null;
	<strong>this.mAnimatedRenderable = null;
	this.mAnimatedGameObject = null;</strong>
    
	this.kTexture = "assets/minion_sprite.png"
};</pre>
		<figcaption class="codecaption">Code snippet 3-3: Adding a second GameObject</figcaption>
        </figure>

    <hr>
    <h2>Conclusion</h2>
        <p>In <a href="tutorial4.html">tutorial 4</a>, we will took a look at SpriteRenderables, SpriteAnimateRenderables and collision detection.</p>
        
        
        <hr>
        <p align="center"><a href="../tutorial2/tutorial2.html">Tutorial 2</a> &lt;-- Tutorial 3 --&gt; <a href="../tutorial4/tutorial4.html">Tutorial 4</a><br>
		  <a href="../index.html">Main tutorial guide page</a><br></p>
	</div>
    </body>
</html>
