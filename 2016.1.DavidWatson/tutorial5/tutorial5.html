<!doctype html>
<html>
	<head>
		<meta charset="UTF-8">
		<link rel="stylesheet" href="../assets/coding.css">
		<title>Tutorial 5</title>
	</head>

	<body>
    	<div id="main-content">
		<h1> GTCS Game Engine: <br>
		Tutorial 5: Illumination</h1>
		<p align="center"><a href="../tutorial4/tutorial4.html">Tutorial 4</a> &lt;-- Tutorial 5 --&gt; <a href="../tutorial6/tutorial6.html">Tutorial 6</a><br>
		  <a href="../index.html">Main tutorial guide page</a><br></p>
		
		
		<hr>
		<h2>Introduction</h2>
		<p>In this tutorial, we are going to look at how to enhance the look of our game scene using lighting effects.</p>
		<p>
		  </p>



	<hr>
		<h2>Illumination</h2>
		<p>In tutorial 2, we have seen the use of ambient lighting to illuminate our renderables. The ambient lighting sources is controlled with the <b>setGlobalAmbientIntensity()</b> function. This source is always active and it adjusts the lighting on all renderables in our scene. If we want to disable the light, we set the intensity to 0. The lighting affect is analagous to increasing the backlight intensity on your cell phone or laptop. Everything gets &quot;brightened&quot; by the same amount.</p>
		<p>The game engine supports 3 other types of light sources.</p>
		<ul>
		  <li>Point - An omnidirectional light source in space. Similar to a hovering firefly with a &quot;sphere of illumination&quot; wherever it goes.</li>
		  <li>Spot - A cone-shaped light source directed at a location. Similar to a flashlight pointing at a wall.</li>
		  <li>Directional - A planar light source where light is equally intense at all incident points. Similar to the screen backlight of electronics devices.</li>
		  </ul>
        <p>These different lighting types have are declared using a number of parameters sent into the Proper use of lighting requires...</p>
        <ol>
        	<li>Declare a light source with the type and parameters defining it's characteristics.</li>
            <li>Idenfity to each applicable renderable that it should account for the light source when drawing itself.</li>
          </ol>
		<p class="note">[Note: This second requirement may seem odd but lighting calculations are essentially a manipulation of how pixels are drawn to the screen (how the object looks). Since we are familiar with the fact that the &quot;look&quot; of game elements is under the purview of the renderable, we treat lighting as a parameter we add to the renderable object.]</p>
        <p>To create a light, we allocate a new Light object and set parameters using accessor methods. There are many settings and certain settings will be used or ignored based on the type of light. Here is an overview of some of the settings we can set...</p>
        <ul>
          <li><code>setLightType()</code> - Identifies what type of light to render as. Valid choices are <strong>Light.eLightType.ePointLight</strong>, <strong>Light.eLightType.eSpotLight</strong> and<strong> Light.eLightType.eDirectionalLight</strong>.</li>
          <li><code>setColor()</code> - Color of the light using a 4-value vector identifying red, green, blue and alpha values from 0.0 to 1.0.</li>
          <li><code>setIntensity()</code> - A value from 0.0 to 1.0 giving the strength of the light.</li>
          <li><code>setXPos(), setYPos(), setZPos()</code> - The functions allow you to set the X, Y and Z coordinates of where the light is positioned in 3D space. While we are working with a 2D game scene, out light needs to exist in 3D space to allow for the calculations to illuminate the scene (used only for point and spot lights).</li>
          <li><code>setNear(), setFar()</code> - The functions allow you to set the radii for the area of affect for light sources. From the center of the light to the near radius, the intensity will be constant. From the near radius to the far radius, the intensity will gradually drop off effectively softening the edges of the area of affect. If you set both values to be the same, the edge of the area of illumination will be very sharp (used only for point and spot lights).</li>
          <li><code>setDropOff()</code> - Identifies how quickly the light intensity will fall as we reach the edge of the area of the lighting affect  (used only for point and spot lights).</li>
          <li><code>setDirection()</code> - Provide a vector of 3 components to identify the direction the light should point (used only for directional and spot lights).</li>
        </ul>
    <h3>Point Lights</h3>
    <p>A point light can be compared to a lightbulb hovering in mid-air illuminating a spherical volume around it. It has intensity, color, size and position. The amount of the game scene that will be illuminated with be determined by the size of the illumination volume (determined by the radius of affect from the center point) and the location of the point. Figure 5-1 provides a visual representation of the affect. To create a point light, we allocate a new Light object and set parameters using accessor methods.</p>
    <figure>
    		<img src="assets/tutorial5-img1.png" width="466" height="211">
        	<figcaption>figure 5-1: Point Light</figcaption>
        </figure></p>
    <p>To demonstrate the creation of a point light, we will allocate a new Light object and set parameters using accessor methods. To illuminate our game objects, we need to use a renderable that knows how to work with lights. The LightRenderable has all of the same functionality as SpriteAnimateRenderable plus the ability to react to lighting affects. You can see the demonstration <a href="../tutorial_source/index5a.html">here</a>.</p>
    <figure>
	  	<pre>
MyGameScene.prototype.initialize  = function () {
	this.mCamera = new Camera(
        vec2.fromValues(50, 40),	// position of the camera
        100,						// width of camera
        [0, 0, 500, 400]			// viewport (orgX, orgY, width, height)
	);
	// set the background color of our view to medium grey
	this.mCamera.setBackgroundColor([0.8, 0.8, 0.8, 1]);
    
	// create a background for the scene
	<strong>this.mBg = new LightRenderable(this.kBG);</strong>
	this.mBg.getXform().setSize(100, 80);
	this.mBg.getXform().setPosition(50, 40);

	// we use a new object type that knows how to render with lights
	<strong>this.mRenderable = new LightRenderable(this.kTexture);</strong>
	this.mRenderable.setElementPixelPositions(130, 310, 0, 180);
    
	<strong>// create the light and setup the parameters we need
	this.mPointLight = new Light();
	this.mPointLight.setLightType(Light.eLightType.ePointLight);
	this.mPointLight.setColor([1.0, 1.0, 1.0, 1]);
	this.mPointLight.setXPos(55);
	this.mPointLight.setYPos(61);
	this.mPointLight.setZPos(-1);<br>	this.mPointLight.setNear(8);<br>	this.mPointLight.setFar(10);
	this.mPointLight.setIntensity(1);</strong>
        
	<strong>// associate the light with the renderables
	this.mBg.addLight(this.mPointLight);
	this.mRenderable.addLight(this.mPointLight);</strong>
        
	// create a new game object with the new renderable
	this.mGameObject = new GameObject(this.mRenderable);
	this.mGameObject.getXform().setSize(16, 16);
	this.mGameObject.getXform().setPosition(30, 50);
    
	// We could create a GameObject for the background but since
	// it will not be interacting with any other object, we 
	// can leave it as a pure renderable
    
	<strong>// we set the ambient light low to emphasize our light affect
	gEngine.DefaultResources.setGlobalAmbientIntensity(0.2);</strong>
};
    	</pre>
    	<figcaption>Code snippet 5-1: Defining a Light Object</figcaption>
    </figure>
    <p>In code snippet 5-1, we created a new point light and set positionNotice in the last line, we set the intensity of the ambient light to 0.2. Ambient light affects all game objects regardless of what type of renderable. We set this low value to dim our scene and to make the point light stand out. For our Update() function, we set it up so that the ASWD keys on the keyboard will control the location of the point light.</p>
    <figure>
	  	<pre>
MyGameScene.prototype.update = function () {
	if (gEngine.Input.isKeyPressed(gEngine.Input.keys.A)) {
		var x = this.mPointLight.getPosition()[0];
		this.mPointLight.setXPos(x - 0.5);
	}
        
	if (gEngine.Input.isKeyPressed(gEngine.Input.keys.D)) {
		var x = this.mPointLight.getPosition()[0];
		this.mPointLight.setXPos(x + 0.5);
	}
    
	if (gEngine.Input.isKeyPressed(gEngine.Input.keys.W)) {
		var y = this.mPointLight.getPosition()[1];
		this.mPointLight.setYPos(y + 0.5);
	}
        
	if (gEngine.Input.isKeyPressed(gEngine.Input.keys.S)) {
		var y = this.mPointLight.getPosition()[1];
		this.mPointLight.setYPos(y - 0.5);
	}
}; 	</pre>
    	<figcaption>Code snippet 5-2: Controlling a Light Object</figcaption>
    </figure>
    <h3>Spot Lights</h3>
    <p>Spot lights are more complex than point lights in that they utilize more parameters to give more of a directional affect than the point light. Using angles as illustrated in figure 5-2, we can see how a spot light illuminates a surface.</p>
    <figure>
    		<img src="assets/tutorial5-img2.png" width="370" height="211">
        	<figcaption>figure 5-2: Spot Light</figcaption>
        </figure>
        <p>The cone angles in figure 5-2 affect the intensity of the light across the area of affect. The attenuation of light over a distance will cause a diffusion on the surface particularly near the edges and these angles are meant to simplify applying this affect. To set these angles, we have a the <code>setInner()</code> and <code>setOuter()</code> functions. These functions accept an angle in radians.</p>
        <h3>Directional Lights</h3>
		<p>A directional light is similar to ambient light in that every pixel illunated by it receives the light with equal intensity. However, while the ambient light source allows us to set just the intensity, we can also define direction for directional light sources. Since we are dealing with two dimensional renderables, the direction of the light is not going to provide a sense of depth like it would in three dimensional space (at least... not yet).</p>

    <h3>&nbsp;</h3>
    <p>&nbsp;</p>
    <hr>
    <h2>Conclusion</h2>
        <p>In <a href="../tutorial6/tutorial6.html">tutorial 6</a>, we will took a look at implementing shadow affects on our renderables.</p>
        
        
        <hr>
        <p align="center"><a href="../tutorial4/tutorial4.html">Tutorial 4</a> &lt;-- Tutorial 5 --&gt; <a href="../tutorial6/tutorial6.html">Tutorial 6</a><br>
		  <a href="../index.html">Main tutorial guide page</a><br></p>
	</div>
    <h4><i>2/3/2016</i> - David Watson</h4>
    </body>
</html>
